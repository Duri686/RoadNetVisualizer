# 当前代码能解决的问题
- **障碍生成与图构建**
  - 随机矩形障碍生成（避免重叠，轻量网格加速）。
  - 单/多层导航图构建，支持 centroid-free、portal、voronoi 模式。
  - 基础 Delaunay/连接网络 Overlay 生成与可视化（edgesPacked 使用 Float32Array + Transferable）。

- **路径计算与后处理**
  - A* 最短路。
  - 可见性平滑与直角化（可选，支持空间索引）。
  - 交互预览路径、最终路径、路径动画与信息面板。

- **空间索引与几何**
  - 均匀网格索引（线段/点的潜在障碍候选查询、DDA 扫格）。

- **渲染与交互**
  - PixiJS 分层渲染：障碍物层、网络节点/边、Voronoi 骨架、Overlay。
  - 图层显隐控制、视图缩放/平移、十字准线、起终点拾取（Delaunay.find）。

# 适用场景
- **小-中规模数据演示**
  - 障碍数：数百到数千（已验证 6.4k 级别可用）。
  - 单层或少数层，面向 Demo、教学、算法验证与交互演示。
- **浏览器端交互探索**
  - 需要快速生成、快速渲染、可预览路径及简单后处理的可视化工具。

# 能力边界（当前实现的实际限制）
- **生成侧**
  - 算法：拒绝采样 + “单障碍超次失败即提前终止”。接近容量上限时接受率骤降，导致远小于目标数（如 1000 请求 → 412 实得）。
  - 数据结构：障碍物以对象数组传输，结构化克隆成本高；未使用 TypedArray/Transferable（仅 overlayPacked 使用）。
  - 边界：在 10k~50k 障碍范围内开始受内存/克隆/早停影响；更高规模需要改算法与数据格式。

- **渲染侧**
  - 每个障碍一个 Graphics + Text（现在还加了索引文本）。对象数与 Draw Calls 快速膨胀。
  - 无视窗裁剪、无静态层缓存，缩放/平移不重用渲染结果。
  - 边界：几千级仍可接受；上万开始掉帧；十万级及以上需要瓦片化+合批+缓存+LOD，百万级必须彻底批渲染（Mesh/Instancing）与强裁剪。

- **路径与图构建**
  - A* 实现为朴素版本：
    - openSet 使用 Set+线性扫描最小 fScore。
    - 邻接访问时多处 O(N) 查找（如 nodes.find）。
  - Layer>0 的边构建对障碍穿越检测为 `obstacles.some`（无空间索引），在高节点数时会非常慢。
  - 边界：当前节点/边规模适中时表现尚可；在高密图（10k+ 节点/边）会显著退化。需要优先队列、id->node 映射、候选障碍用网格索引。

- **空间索引**
  - 网格键为字符串 “ix,iy”，Map+数组存储，内存额外开销大；大规模下需要 SOA + 数组化键或分块结构。
  - 构建与查询为 O(N) 级别可接受，但 100k~1M 需 TypedArray/分块/批构建。

- **进程间传输**
  - 主要数据（障碍、节点、边）以对象数组结构化克隆；未采用批量流式与零拷贝传输。
  - 边界：>10k~50k 开始成为瓶颈；100k+ 必须 Transferable + 批处理。

# 已观测到/可观测的性能指标
- 已有指标（Worker 回传 metadata.workerProfile）：
  - **障碍生成时间** `obstaclesMs`
  - **构建时间** `buildMs`
  - **Overlay 时间** `overlayMs`
- 已有日志与面板：
  - **渲染入口**：层数、障碍数打印。
  - **路径后处理**：平滑与直角化耗时（smoothMs 累积）。
- 从你的数据参考（部分示例）：
  - 6.4k 障碍案例：生成 33ms、Delaunay 1ms、边遍历 3ms、候选查询 6ms、穿障 2ms、构建 26ms、Overlay 14ms、初始化渲染 75ms、渲染 84ms、总体数据体积 ~2.1MB（这些值说明在中规模时整体表现良好）。
  - 1k 请求但仅 412 实得：生成阶段早停。

- 建议补充的关键指标（便于向 10万/百万演进）：
  - **生成**：目标数、已放置数、尝试总数、接受率、平均尝试/障碍、连续失败计数、提前终止原因、估算占用率。
  - **索引**：构建时间、格子数量、平均每格实体数。
  - **构建**：节点数/边数、每条边的候选障碍数均值、穿障检查次数与耗时。
  - **传输**：消息大小、Transferable 数量、总时间。
  - **渲染**：首次绘制耗时、重绘耗时、对象数/Draw Calls、帧时间（近似）。
  - **路径查询**：A* 扩展节点数、开放集峰值、总耗时、后处理各项耗时。

# 现状性能结论（保守估计）
- **生成时间**：当前算法在中等密度下可达几十毫秒级，但接近容量上限时会早停；想要“目标数量可控”需更换策略（Poisson/格网/两阶段装箱）或动态缩尺。
- **渲染时间**：中规模（几千）可控；上万开始明显上升；当前结构不适配十万级（对象/绘制过多，缺乏裁剪与缓存）。
- **路径时间**：在当前节点/边规模下表现尚可；高规模将因 A* 朴素实现与边构建穿障检查退化而显著上涨。

# 面向 10万/百万级的缺口与路线
- **数据结构与传输**
  - 用 SOA/TypedArray 存储障碍、节点、边；Worker→主线程采用 Transferable（零拷贝）。
  - 批量/流式传输（每批 1k/5k）+ 总线对齐的内存布局，避免一次性克隆/分配。

- **生成**
  - 从拒绝采样切换至容量可控方法（格网或 Poisson 盘采样）；当目标数>可装容量时，自适应缩尺或分档尺寸。
  - 不早停：采用全局尝试上限或分阶段降尺寸/间距回退策略。

- **索引**
  - 分块网格（整数键或多维索引）、TypedArray 存储指针；批量构建。
  - 所有穿障/邻域查询统一走索引，不使用 `obstacles.some`。

- **构建与路径**
  - Layer>0 的边构建必须基于空间索引而非全表扫描；或采用稀疏连接策略（k-NN/半径限制 + 局部可见性）。
  - A* 使用最小堆优先队列；预建 `id->node` 映射；必要时采用多层图/跳点/CH（按产品目标再选）。

- **渲染**
  - 瓦片化 + 视窗裁剪。
  - 静态层 RenderTexture 缓存；参数不变不重绘。
  - 障碍合批（单 Graphics/Mesh/Instanced），索引文本改 BitmapText 或近景 LOD；远景隐藏。
  - 按需风格：先保证轮廓，再逐步开启叠加与标签。

# 推荐的下一步（不立即改动核心逻辑）
- **加指标埋点（仅日志，不改变行为）**：生成接受率/尝试次数/退出原因、索引构建、穿障统计、传输体积、渲染帧耗、路径扩展。
- **无渲染压测模式**：Worker 内批量生成 10万级（甚至 100万）仅回传统计，评估时间/内存与传输上限。
- 在此基础上，再选择：
  - 生成算法替换（容量可控）；
  - 传输/内存 SOA 化；
  - 渲染“裁剪+缓存+合批”。

# 总结
- 当前版本非常适合小中规模交互演示与算法验证（数千级障碍），并具备基础的可观测指标与空间索引。
- 朝 10万/百万级迈进的主要短板是：生成拒绝采样的早停、对象数组的传输与内存开销、渲染对象/Draw Calls 爆炸、Layer>0 构建与 A* 的朴素实现。
- 建议先补齐“指标与压测模式”，随后按“数据结构/生成/索引/渲染/路径”的顺序逐步升级，以确保每一步都能量化收益与边界。